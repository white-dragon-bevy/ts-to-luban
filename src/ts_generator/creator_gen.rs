use super::import_resolver::ImportResolver;
use super::to_kebab_case;
use crate::parser::{ClassInfo, FieldInfo};
use std::collections::HashSet;
use std::path::Path;

pub struct CreatorGenerator<'a> {
    import_resolver: &'a ImportResolver,
    all_classes: &'a [ClassInfo],
}

impl<'a> CreatorGenerator<'a> {
    pub fn new(import_resolver: &'a ImportResolver, all_classes: &'a [ClassInfo]) -> Self {
        Self {
            import_resolver,
            all_classes,
        }
    }

    /// Generate creator file content for a class
    pub fn generate(&self, class: &ClassInfo, output_file: &Path) -> String {
        let import_path = self
            .import_resolver
            .resolve(output_file, Path::new(&class.source_file));

        // Collect nested bean types used in fields
        let nested_beans: HashSet<String> = class
            .fields
            .iter()
            .filter(|f| !f.is_object_factory && self.is_bean_type(&f.original_type))
            .map(|f| self.extract_bean_name(&f.original_type))
            .filter(|name| name != &class.name) // Don't import self
            .collect();

        let mut lines = vec![
            "// Auto-generated by ts-to-luban".to_string(),
            format!("import {{ {} }} from \"{}\";", class.name, import_path),
            "import { createBean } from \"../registry\";".to_string(),
        ];

        // Add imports for nested bean types from their creator files
        for bean_name in &nested_beans {
            lines.push(format!(
                "import {{ {} }} from \"./{}\";",
                bean_name,
                to_kebab_case(bean_name)
            ));
        }

        lines.push(String::new());
        // Re-export the class for consumers
        lines.push(format!(
            "export {{ {} }} from \"{}\";",
            class.name, import_path
        ));
        lines.push(String::new());

        // Generate creator function
        lines.push(format!(
            "export function create{}(json: unknown): {} {{",
            class.name, class.name
        ));
        lines.push(format!("    const obj = new {}();", class.name));

        // Collect parent class names in inheritance chain (from top to bottom)
        let mut parent_chain = Vec::new();
        let mut current_parent = class.extends.as_ref();
        while let Some(parent_name) = current_parent {
            parent_chain.push(parent_name.clone());
            if let Some(parent) = self.all_classes.iter().find(|c| &c.name == parent_name) {
                current_parent = parent.extends.as_ref();
            } else {
                break;
            }
        }
        parent_chain.reverse(); // Reverse to get top-level parent first

        // Collect child class field names to check for redeclarations
        let child_field_names: HashSet<&str> =
            class.fields.iter().map(|f| f.name.as_str()).collect();

        // Generate field assignments for parent classes first
        // Skip fields that are redeclared in the child class
        for parent_name in &parent_chain {
            if let Some(parent) = self.all_classes.iter().find(|c| &c.name == parent_name) {
                for field in &parent.fields {
                    // Skip if this field is redeclared in the child class
                    if !child_field_names.contains(field.name.as_str()) {
                        let assignment = self.generate_field_assignment(field);
                        lines.push(format!("    {}", assignment));
                    }
                }
            }
        }

        // Then generate field assignments for the current class
        for field in &class.fields {
            let assignment = self.generate_field_assignment(field);
            lines.push(format!("    {}", assignment));
        }

        lines.push("    return obj;".to_string());
        lines.push("}".to_string());

        lines.join("\n")
    }

    fn generate_field_assignment(&self, field: &FieldInfo) -> String {
        let name = &field.name;

        if field.is_object_factory {
            // ObjectFactory<T> → factory function
            if field.field_type.starts_with("list,") {
                // Use 'in' operator to check if property exists (works better in roblox-ts/luau)
                format!("obj.{} = \"{}\" in (json as Record<string, unknown>) ? ((json as Record<string, unknown>).{} as defined[]).map(item => {{ const data = item as Record<string, unknown>; return () => createBean(data.$type as string, data); }}) : [];", name, name, name)
            } else {
                format!("obj.{} = (() => {{ const data = (json as Record<string, unknown>).{} as Record<string, unknown>; return () => createBean(data.$type as string, data); }})();", name, name)
            }
        } else if field.is_constructor {
            // Constructor<T> → string (class name)
            // In JSON, it's stored as string class name like "DamageTrigger"
            // At runtime, we can't validate string is actual Constructor<T>
            // Use 'as any' to bypass type checking since it's inherently unsafe
            format!(
                "obj.{} = (json as Record<string, unknown>).{} as any;",
                name, name
            )
        } else if !self.is_bean_type(&field.original_type)
            && (field.original_type.ends_with("[]") || field.original_type.starts_with("list,"))
        {
            // Primitive array type - use 'in' operator
            format!("obj.{} = \"{}\" in (json as Record<string, unknown>) ? (json as Record<string, unknown>).{} as {} : [];", name, name, name, self.ts_type_for_field(&field.original_type))
        } else if self.is_bean_type(&field.original_type) {
            // Nested bean
            let bean_name = self.extract_bean_name(&field.original_type);
            if field.field_type.starts_with("list,") {
                // Use 'in' operator to check if property exists
                format!("obj.{} = \"{}\" in (json as Record<string, unknown>) ? ((json as Record<string, unknown>).{} as defined[]).map(item => createBean<{}>(\"{}\", item)) : [];", name, name, name, bean_name, bean_name)
            } else {
                format!(
                    "obj.{} = createBean<{}>(\"{}\", (json as Record<string, unknown>).{});",
                    name, bean_name, bean_name, name
                )
            }
        } else {
            // Primitive type
            format!(
                "obj.{} = (json as Record<string, unknown>).{} as {};",
                name,
                name,
                self.ts_type_for_field(&field.original_type)
            )
        }
    }

    fn is_bean_type(&self, type_str: &str) -> bool {
        // Handle both TypeScript format (X[]) and Luban format (list,X)
        let clean_type = if type_str.starts_with("list,") {
            type_str.trim_start_matches("list,")
        } else {
            type_str.trim_end_matches("[]")
        };
        // Check if type matches a known class
        self.all_classes.iter().any(|c| c.name == clean_type)
    }

    fn extract_bean_name(&self, type_str: &str) -> String {
        // Extract class name from type like "DropItem", "DropItem[]", or "list,DropItem"
        if type_str.starts_with("list,") {
            type_str.trim_start_matches("list,").to_string()
        } else {
            type_str.trim_end_matches("[]").to_string()
        }
    }

    fn ts_type_for_field(&self, original_type: &str) -> String {
        // Map original TypeScript type to a type for casting
        // Handle both TypeScript format (X[]) and Luban format (list,X)
        if original_type.ends_with("[]") {
            let inner = original_type.trim_end_matches("[]");
            let inner_type = match inner {
                "number" | "int" | "float" | "long" | "double" => "number",
                "string" => "string",
                "boolean" | "bool" => "boolean",
                _ => inner, // Keep class names as-is
            };
            format!("{}[]", inner_type)
        } else if original_type.starts_with("list,") {
            let inner = original_type.trim_start_matches("list,");
            let inner_type = match inner {
                "number" | "int" | "float" | "long" | "double" => "number",
                "string" => "string",
                "boolean" | "bool" => "boolean",
                _ => inner, // Keep class names as-is
            };
            format!("{}[]", inner_type)
        } else {
            match original_type {
                "number" | "int" | "float" | "long" | "double" => "number".to_string(),
                "string" => "string".to_string(),
                "boolean" | "bool" => "boolean".to_string(),
                _ => "unknown".to_string(),
            }
        }
    }
}
